#gpt Service
import os
import json
import re
import traceback
import importlib
import inspect
import unidecode
from datetime import datetime, timedelta
from prompts.manual_secretaria import INSTRUCAO_SECRETARIA
from utils.contexto_temporario import carregar_contexto_temporario, salvar_contexto_temporario
from utils.custos_gpt import registrar_custo_gpt
from firebase_admin import firestore
from utils.formatters import adaptar_genero
from utils.interpretador_datas import interpretar_data_e_hora
from services.session_service import pegar_sessao, resetar_sessao
from utils.context_manager import atualizar_contexto, limpar_contexto, limpar_contexto_agendamento
from services.profissional_service import listar_servicos_cadastrados, obter_precos_servico, encontrar_servico_mais_proximo, consultar_todos_precos
from services.gpt_client import client
from utils.gpt_utils import (
    montar_prompt_com_contexto,
    formatar_descricao_evento,
    estimar_duracao,
    formatar_data,
)
from services.gpt_actions import (
    executar_acao_gpt_por_confirmacao,
    executar_confirmacao_generica,
)

from services.firebase_service_async import buscar_cliente
from services.gpt_service import executar_confirmacao_generica

# ‚úÖ GPT simples para respostas diretas (com plano e m√≥dulos no prompt)
async def processar_com_gpt(texto_usuario, user_id="desconhecido"):
    try:
        # üîç Busca os dados do cliente
        cliente = await buscar_cliente(user_id)
        pagamento_ativo = cliente.get("pagamentoAtivo", False) if cliente else False
        planos_ativos = cliente.get("planosAtivos", []) if cliente else []

        # üß† Monta prompt com os dados de plano
        prompt_completo = f"""
üìå Plano ativo: {pagamento_ativo}
üîê M√≥dulos: {', '.join(planos_ativos) or 'Nenhum'}

üó£Ô∏è Mensagem do usu√°rio:
\"{texto_usuario}\"
"""

        resposta = await client.chat.completions.create(
            model="gpt-4o",
            temperature=0.4,
            messages=[
                {"role": "system", "content": INSTRUCAO_SECRETARIA},
                {"role": "user", "content": prompt_completo}
            ]
        )

        # üîç Registrar custo da chamada
        firestore_client = firestore.client()
        await registrar_custo_gpt(resposta, "gpt-4o", user_id, firestore_client)

        # ‚úÖ Extrai conte√∫do de forma segura
        try:
            conteudo = resposta.choices[0].message.content
            if conteudo:
                return conteudo.strip()
            else:
                raise ValueError("Conte√∫do da resposta do GPT veio vazio.")
        except Exception as e:
            print("‚ùå Erro ao extrair resposta do GPT:", e)
            print("üßæ Objeto resposta:", resposta.model_dump_json(indent=2, ensure_ascii=False))
            return "‚ùå A IA n√£o conseguiu entender seu pedido. Pode reformular?"

    except Exception as e:
        print(f"‚ùå Erro no GPT:", e)
        return "‚ùå Houve um erro ao processar com a IA."

async def tratar_mensagem_usuario(user_id, mensagem):
    print("üî• [gpt_service] Entrou no tratar_mensagem_usuario via importlib")

    # üëá Essa linha mostra de onde a fun√ß√£o est√° sendo chamada
    print("üìç Stack de chamada:")
    for frame in inspect.stack()[1:5]:  # mostra os 4 n√≠veis anteriores
        print(f" - Arquivo: {frame.filename}, Linha: {frame.lineno}, Fun√ß√£o: {frame.function}")

    # Carrega a fun√ß√£o original dinamicamente
    acao_handler = importlib.import_module("handlers.acao_handler")
    return await acao_handler.tratar_mensagem_usuario(user_id, mensagem)

# ‚úÖ GPT com contexto e resposta estruturada em JSON (a√ß√£o + dados)
async def processar_com_gpt_com_acao(texto_usuario, contexto, instrucao):
    print("üö® [gpt_service] Arquivo carregado")
    try:
        user_id = str(contexto.get('usuario', {}).get('user_id', 'desconhecido'))
        texto_normalizado = unidecode.unidecode(texto_usuario.lower().strip())

        # üõ°Ô∏è Evita resposta repetitiva com 'None' ap√≥s conversa conclu√≠da
        SAUDACOES_INICIAIS = [
            "oi", "ola", "ol√°", "opa", "e a√≠", "ea√≠", "bom dia", "boa tarde", "boa noite",
            "tudo bem", "como vai", "beleza", "salve", "fala a√≠", "fala", "oi√™", "oi oi"
        ]

        if texto_normalizado in SAUDACOES_INICIAIS:
            try:
                # üëã Oi depois de agendamento conclu√≠do ‚Üí limpar contexto
                if contexto_salvo.get("evento_criado") and contexto_salvo.get("ultima_acao") == "criar_evento":
                    await limpar_contexto_agendamento(user_id)  # üßπ limpa apenas dados de agendamento
                    await limpar_contexto(user_id)
                    return {
                        "resposta": "üëã Ol√°! Em que mais posso te ajudar hoje?",
                        "acao": None,
                        "dados": {}
                    }

                # üòé Oi durante um fluxo incompleto ‚Üí retomar de onde parou
                elif any(contexto_salvo.get(k) for k in ["servico", "data_hora", "profissional_escolhido"]):
                    partes = []
                    if contexto_salvo.get("servico"):
                        partes.append(f"{contexto_salvo['servico']}")
                    if contexto_salvo.get("profissional_escolhido"):
                        partes.append(f"com {contexto_salvo['profissional_escolhido']}")
                    if contexto_salvo.get("data_hora"):
                        partes.append(f"para {formatar_data(contexto_salvo['data_hora'])}")

                    resumo = " ".join(partes)

                    return {
                        "resposta": f"Estamos no meio de um agendamento de {resumo}. Deseja confirmar, alterar ou cancelar?",
                        "acao": None,
                        "dados": {}
                    }

                # üëã Oi fora de qualquer fluxo ‚Üí in√≠cio normal
                else:
                    return {
                        "resposta": "üëã Ol√°! Como posso te ajudar hoje?",
                        "acao": None,
                        "dados": {}
                    }

            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao tratar sauda√ß√£o com contexto: {e}")
                return {
                    "resposta": "üëã Ol√°! Como posso te ajudar hoje?",
                    "acao": None,
                    "dados": {}
                }

        # ‚úÖ Carrega o contexto antes de usar
        contexto_salvo = await carregar_contexto_temporario(user_id) or {}
        if contexto_salvo.get("profissional_escolhido"):
            contexto_salvo.pop("ultima_opcao_profissionais", None)

        # üßº Se a inten√ß√£o mudou e temos contexto salvo de agendamento, limpa tudo
        if intencao not in ["AGENDAR", "DESCONHECIDO"] and any(
            contexto_salvo.get(k) for k in ["profissional_escolhido", "servico", "data_hora"]
        ):
            print("üîÑ Mudan√ßa de inten√ß√£o detectada. Limpando contexto antigo.")
            await limpar_contexto(user_id)
            await resetar_sessao(user_id)
            contexto_salvo = {}

        # üö´ Detecta inten√ß√£o de cancelamento expl√≠cita
        texto_lower = texto_usuario.strip().lower()
        palavras_cancelamento = [
            "cancela", "cancelar", "n√£o quero", "nao quero", "esquece", "deixa pra l√°", "deixa pra la",
            "parei", "sai", "n√£o desejo mais", "desisto"
        ]
        if any(p in texto_lower for p in palavras_cancelamento):
            print("üõë Cancelamento detectado. Limpando contexto.")
            await limpar_contexto_agendamento(user_id)
            await limpar_contexto(user_id)
            await resetar_sessao(user_id)
            contexto_salvo = {}

            return {
                "resposta": "‚úÖ Tudo bem, cancelei o agendamento em andamento. Se precisar de algo, estou aqui!",
                "acao": None,
                "dados": {}
            }

        # ‚úÖ Atualiza data/hora inteligente no contexto se aplic√°vel
        data_inteligente = interpretar_data_e_hora(texto_usuario)
        if data_inteligente:
            nova_data_iso = data_inteligente.replace(second=0, microsecond=0).isoformat()
            if nova_data_iso != contexto_salvo.get("data_hora"):
                contexto_salvo["data_hora"] = nova_data_iso
                print(f"üß† Data/hora atualizada para: {nova_data_iso}")
                await salvar_contexto_temporario(user_id, contexto_salvo)

        # üß† Extra√ß√£o antecipada
        texto_normalizado = unidecode.unidecode(texto_usuario.lower())
        data_hora_detectada = interpretar_data_e_hora(texto_usuario)
        servico_mencionado = None

        for p in contexto.get("profissionais", []):
            for s in p.get("servicos", []):
                if s.lower() in texto_normalizado:
                    servico_mencionado = s.lower()
                    break

        profissional_mencionado = None
        for p in contexto.get("profissionais", []):
            if p["nome"].lower() in texto_normalizado:
                profissional_mencionado = p["nome"]
                break

        # Atualiza contexto
        if profissional_mencionado and not contexto_salvo.get("profissional_escolhido"):
            contexto_salvo["profissional_escolhido"] = profissional_mencionado
        if servico_mencionado and not contexto_salvo.get("servico"):
            contexto_salvo["servico"] = servico_mencionado
        if data_hora_detectada and not contexto_salvo.get("data_hora"):
            contexto_salvo["data_hora"] = data_hora_detectada.replace(second=0, microsecond=0).isoformat()

        await salvar_contexto_temporario(user_id, contexto_salvo)

        # üóÇÔ∏è Detectar pedido de todos os pre√ßos
        gatilhos_todos_precos = [
            "todos os precos", "traga todos os precos", "mostrar todos os precos",
            "quais os precos", "listar precos", "precos de tudo", "todos precos", "precos completos", "me traga todos os precos",
            "todos os valores", "traga todos os valores", "mostrar todos os valores",
            "quais os valores", "listar valores", "valores de tudo", "todos valores", "valores completos", "me traga todos os valores"
        ]

        pedir_todos_precos = any(
            frase in texto_normalizado for frase in gatilhos_todos_precos
        )

        if pedir_todos_precos:
            print(f"‚úÖ Gatilho acionado para TODOS PRE√áOS. Texto: {texto_normalizado}")
            precos_texto = await consultar_todos_precos(user_id)
            return {
                "resposta": precos_texto,
                "acao": "responder_informacao",
                "dados": {}
            }
 
        # üí∞ Consulta de pre√ßo tratada localmente (sem chamar o GPT)
        menciona_preco = any(
            chave in texto_normalizado for chave in ["preco", "pre√ßo", "valor", "custa", "quanto custa"]
        )

        if menciona_preco:
            from services.profissional_service import obter_precos_servico
            from services.normalizacao_service import encontrar_servico_mais_proximo

            if not servico_mencionado:
                servico_mencionado = await encontrar_servico_mais_proximo(texto_usuario, user_id)
                print(f"üîç Servi√ßo mencionado ap√≥s normaliza√ß√£o: {servico_mencionado}")

            if servico_mencionado:
                if profissional_mencionado:
                    preco = await obter_precos_servico(
                        user_id, servico_mencionado, profissional_mencionado
                    )
                    if preco is not None:
                        try:
                            valor_formatado = f"{float(preco):.2f}"
                        except Exception:
                            valor_formatado = str(preco)
                        resposta = (
                            f"O pre√ßo de *{servico_mencionado}* com *{profissional_mencionado}* √© R$ {valor_formatado}"
                        )
                    else:
                        resposta = (
                            f"Infelizmente n√£o temos o pre√ßo de {servico_mencionado} com {profissional_mencionado} ainda."
                        )
                else:
                    precos = await obter_precos_servico(user_id, servico_mencionado)
                    if not precos:
                        # tenta normalizar o servi√ßo se n√£o encontrou nenhum pre√ßo
                        servico_sugerido = await encontrar_servico_mais_proximo(texto_usuario, user_id)
                        if servico_sugerido and servico_sugerido != servico_mencionado:
                            servico_mencionado = servico_sugerido
                            precos = await obter_precos_servico(user_id, servico_mencionado)

                    if precos:
                        resposta = f"Valores de *{servico_mencionado}*:\n"
                        for nome, preco_val in precos.items():
                            try:
                                valor_formatado = f"{float(preco_val):.2f}"
                            except Exception:
                                valor_formatado = str(preco_val)
                            resposta += f"- *{nome}*: R$ {valor_formatado}\n"
                    else:
                        resposta = "Infelizmente n√£o temos esse pre√ßo ainda."
            else:
                resposta = "‚ùå N√£o consegui identificar o servi√ßo para informar o pre√ßo. Voc√™ pode tentar reformular a pergunta?"

            await atualizar_contexto(user_id, {"usuario": texto_usuario, "bot": resposta})

            return {
                "resposta": resposta,
                "acao": None,
                "dados": {}
            }

        # üß† Verifica se o usu√°rio respondeu com um hor√°rio contido nas sugest√µes anteriores
        if contexto_salvo and contexto_salvo.get("sugestoes") and not contexto_salvo.get("data_hora_confirmada"):
            data_base = contexto_salvo.get("data_hora", "")[:10]
            sugestoes = contexto_salvo.get("sugestoes", [])
            texto_normalizado = unidecode.unidecode(texto_usuario.lower())

            # Tenta extrair hor√°rio do texto do usu√°rio
            match_horario = re.search(r"\b(\d{1,2}):(\d{2})\b", texto_normalizado)
            if match_horario and data_base:
                hora_encontrada = match_horario.group(0)  # ex: "08:00"
                for sugestao in sugestoes:
                    if sugestao.startswith(hora_encontrada):
                        nova_data_hora = f"{data_base}T{hora_encontrada}:00"
                        contexto_salvo["data_hora"] = nova_data_hora
                        contexto_salvo["data_hora_confirmada"] = True  # evita substituir depois
                        print(f"üïì Hor√°rio confirmado manualmente: {nova_data_hora}")
                        await salvar_contexto_temporario(user_id, contexto_salvo)
                        break

                print(f"üß† [DEBUG CONTEXTO] ap√≥s confirma√ß√£o manual: {json.dumps(contexto_salvo, indent=2, ensure_ascii=False)}")


        # ‚ö° Detecta troca direta para profissional sugerido (ex: "agende com a Carla")
        resposta_direta = texto_usuario.strip().lower()
        texto_normalizado = unidecode.unidecode(resposta_direta)
        alternativa = (contexto_salvo.get("alternativa_profissional") or "").lower() if contexto_salvo else ""

        if alternativa and alternativa in texto_normalizado:
            profissional = alternativa.capitalize()
            contexto_salvo["profissional_escolhido"] = profissional

            servico = contexto_salvo.get("servico")
            data_hora = contexto_salvo.get("data_hora")
            duracao = estimar_duracao(servico)

            if servico and data_hora:
                # ‚ö†Ô∏è Verifica se o novo profissional est√° realmente dispon√≠vel no mesmo hor√°rio
                from services.event_service_async import verificar_conflito_e_sugestoes_profissional
                data_str = datetime.fromisoformat(data_hora).strftime("%Y-%m-%d")
                hora_str = datetime.fromisoformat(data_hora).strftime("%H:%M")

                conflito = await verificar_conflito_e_sugestoes_profissional(
                    user_id=user_id,
                    data=data_str,
                    hora_inicio=hora_str,
                    duracao_min=duracao,
                    profissional=profissional,
                    servico=servico
                )

                if not conflito["conflito"]:
                    contexto_salvo.update({
                        "profissional_escolhido": profissional,
                        "evento_criado": True,
                        "ultima_acao": "criar_evento",
                        "ultima_intencao": "criar_evento",
                        "dados_anteriores": {
                            "data_hora": data_hora,
                            "descricao": formatar_descricao_evento(servico, profissional),
                            "duracao": duracao,
                            "profissional": profissional
                        }
                    })
                    await salvar_contexto_temporario(user_id, contexto_salvo)

                    return {
                        "resposta": f"‚úÖ {servico.capitalize()} agendado com {profissional} para {formatar_data(data_hora)}.",
                        "acao": "criar_evento",
                        "dados": {
                            "profissional": profissional,
                            "servico": servico,
                            "data_hora": data_hora,
                            "duracao": duracao,
                            "descricao": formatar_descricao_evento(servico, profissional)
                        }
                    }
                else:
                    return {
                        "resposta": f"‚ö†Ô∏è {profissional} est√° ocupado nesse hor√°rio. Deseja escolher outro hor√°rio ou outra profissional?",
                        "acao": None,
                        "dados": {}
                    }

        # ‚ö° Reconhecer respostas curtas de confirma√ß√£o
        palavras_confirmacao = [
            "confirmar", "pode ser", "pode marcar", "fechar",
            "t√° bom", "tudo certo", "ok", "isso", "agendar", "sim", "beleza", "claro",
            "desejo continuar", "quero continuar", "continuar", "vamos continuar"
        ]
        resposta_curta = (
            any(p in resposta_direta for p in palavras_confirmacao)
            and len(resposta_direta.split()) <= 6  # aumentei de 4 para 6 para pegar varia√ß√µes como "desejo continuar agora"
        )

        if resposta_curta and contexto_salvo.get("ultima_acao"):
            print("‚úÖ Detectada confirma√ß√£o de continuidade.")

            # ‚úÖ Verifica se a √∫ltima mensagem do BOT foi uma sugest√£o ou pergunta
            historico = contexto_salvo.get("historico", [])
            if historico:
                ultima_interacao = historico[-1]
                ultima_mensagem_bot = ultima_interacao.get("bot", "").lower()

                print("üß™ [DEBUG] √öltima mensagem do bot:", ultima_mensagem_bot)

                if any(p in ultima_mensagem_bot for p in [
                    "deseja", "prefere", "posso", "quer que", "confirmar", "gostaria", "agendar", "continuar", "seguir", "fechar", "?", "vamos", "pode"
                ]):
                    print("üß† √öltima mensagem do bot indica a√ß√£o pendente.")
                    print("‚û°Ô∏è Executando a√ß√£o confirmada:", contexto_salvo.get("ultima_acao"))
                    return await executar_confirmacao_generica(user_id, contexto_salvo)
                else:
                    print("üö´ √öltima mensagem do bot n√£o parece ser uma sugest√£o de a√ß√£o.")
            else:
                print("üö´ Sem hist√≥rico suficiente para validar confirma√ß√£o.")

            # ‚õîÔ∏è Caso n√£o seja uma resposta a uma sugest√£o, n√£o executa a√ß√£o
            return {
                "resposta": "‚ùå N√£o entendi o que deseja continuar. Pode repetir o pedido?",
                "acao": None,
                "dados": {}
            }

        # ‚úÖ Verifica se h√° novos dados antes de seguir
        tem_novos_dados = profissional_mencionado or servico_mencionado or data_hora_detectada

        # Se o usu√°rio n√£o trouxe novos dados, e j√° temos um contexto anterior incompleto
        if not tem_novos_dados:
            if all(contexto_salvo.get(k) for k in ["profissional_escolhido", "servico", "data_hora"]):
                return {
                    "resposta": (
                        f"Voc√™ mencionou um {contexto_salvo['servico']} com "
                        f"{contexto_salvo['profissional_escolhido']} para "
                        f"{formatar_data(contexto_salvo['data_hora'])}. "
                        "Deseja confirmar, alterar ou cancelar?"
                    ),
                    "acao": None,
                    "dados": {}
                }
            elif any(contexto_salvo.get(k) for k in ["servico", "data_hora", "profissional_escolhido"]):
                partes = []
                if contexto_salvo.get("servico"):
                    partes.append(f"um {contexto_salvo['servico']}")
                if contexto_salvo.get("profissional_escolhido"):
                    partes.append(f"com {contexto_salvo['profissional_escolhido']}")
                if contexto_salvo.get("data_hora"):
                    partes.append(f"para {formatar_data(contexto_salvo['data_hora'])}")

                resumo = " ".join(partes) if partes else "um agendamento"

                # üß† Salva a inten√ß√£o pendente no contexto
                contexto_salvo["ultima_acao"] = "criar_evento"
                contexto_salvo["ultima_intencao"] = "criar_evento"
                contexto_salvo["dados_anteriores"] = {
                    "profissional": contexto_salvo.get("profissional_escolhido"),
                    "servico": contexto_salvo.get("servico"),
                    "data_hora": contexto_salvo.get("data_hora"),
                    "duracao": estimar_duracao(contexto_salvo.get("servico", ""))
                }
                await salvar_contexto_temporario(user_id, contexto_salvo)
                await limpar_contexto_agendamento(user_id)

                return {
                    "resposta": (
                        f"Voc√™ estava iniciando {resumo}. "
                        "Deseja continuar ou come√ßar algo novo?"
                    ),
                    "acao": None,
                    "dados": {}
                }

        #üîíVerifica se h√° sess√£o pendente (ex: aguardando_profissional)
        sessao = await pegar_sessao(user_id)
        if sessao and sessao.get("estado") in ["aguardando_profissional", "aguardando_nome_cliente"]:
            resposta = await tratar_mensagem_usuario(user_id, texto_usuario)
            return {
                "resposta": resposta,
                "acao": None,
                "dados": {}
            }

        contexto = contexto or {}  # <- esta linha precisa vir ANTES do .get
        profissionais = contexto.get("profissionais", [])
        texto_normalizado = unidecode.unidecode(texto_usuario.lower())

        # üìã Verifica se o usu√°rio quer apenas a lista de servi√ßos dispon√≠veis
        intencao_listar_servicos = any(
            chave in texto_normalizado
            for chave in [
                "quais servicos",
                "quais servi√ßos",
                "servicos voce tem",
                "servi√ßos voc√™ tem",
                "lista de servicos",
                "lista de servi√ßos",
                "que servicos",
                "que servi√ßos",
            ]
        )
        if intencao_listar_servicos:
            servicos = await listar_servicos_cadastrados(user_id)
            if servicos:
                resposta = "Aqui est√£o os servi√ßos dispon√≠veis:\n- " + "\n- ".join(servicos)
            else:
                resposta = "N√£o h√° servi√ßos cadastrados no momento."
            await atualizar_contexto(
                user_id,
                {"usuario": texto_usuario, "bot": resposta},
            )
            return {"resposta": resposta, "acao": None, "dados": {}}

        # ‚úÖ Atualiza a data/hora com base na nova mensagem, se for diferente
        nova_data = interpretar_data_e_hora(texto_usuario)
        if nova_data:
            nova_data_iso = nova_data.replace(second=0, microsecond=0).isoformat()
            if nova_data_iso != contexto_salvo.get("data_hora"):
                print(f"üÜï Substituindo data/hora antiga ({contexto_salvo.get('data_hora')}) por nova ({nova_data_iso})")
                contexto_salvo["data_hora"] = nova_data_iso
                await salvar_contexto_temporario(user_id, contexto_salvo)

        # ‚úÖ Tenta agendar diretamente se contexto completo
        if all(contexto_salvo.get(k) for k in ["profissional_escolhido", "servico", "data_hora"]):
            try:
                profissional = contexto_salvo["profissional_escolhido"]
                servico = contexto_salvo["servico"]
                data_hora = contexto_salvo["data_hora"]

                duracao = estimar_duracao(servico)
                from services.event_service_async import verificar_conflito_e_sugestoes_profissional
                data = datetime.fromisoformat(data_hora).strftime("%Y-%m-%d")
                hora = datetime.fromisoformat(data_hora).strftime("%H:%M")
                
                conflito = await verificar_conflito_e_sugestoes_profissional(
                    user_id=user_id,
                    data=data,
                    hora_inicio=hora,
                    duracao_min=duracao,
                    profissional=profissional,
                    servico=servico,
                )

                if not conflito["conflito"]:
                    contexto_salvo.update(
                        {
                            "evento_criado": True,
                            "ultima_acao": "criar_evento",
                            "dados_anteriores": {
                                "data_hora": data_hora,
                                "descricao": formatar_descricao_evento(
                                    servico, profissional
                                ),
                                "duracao": duracao,
                                "profissional": profissional,
                            },
                        }
                    )
                    await salvar_contexto_temporario(user_id, contexto_salvo)

                    return {
                        "resposta": f"{servico.capitalize()} agendado com {profissional} para {formatar_data(data_hora)}. ‚úÇÔ∏è",
                        "acao": "criar_evento",
                        "dados": {
                            "data_hora": data_hora,
                            "descricao": formatar_descricao_evento(
                                servico, profissional
                            ),
                            "duracao": duracao,
                            "profissional": profissional,
                        },
                    }
                else:
                    sugestoes_txt = (
                        "\n".join(f"üîÑ {h}" for h in conflito["sugestoes"])
                        if conflito["sugestoes"]
                        else ""
                    )
                    sugestao_formatada = (
                        f"\n\nüìå *Hor√°rios dispon√≠veis com {profissional}:*\n{sugestoes_txt}"
                        if sugestoes_txt else ""
                    )
                    alternativa_formatada = (
                        f"\n\nüí° {conflito['profissional_alternativo']} est√° dispon√≠vel √†s {hora}."
                        if conflito.get("profissional_alternativo") else ""
                    )

                    await salvar_contexto_temporario(
                        user_id,
                        {
                            "profissional_escolhido": profissional,
                            "servico": servico,
                            "data_hora": data_hora,
                            "sugestoes": conflito["sugestoes"],
                            "alternativa_profissional": conflito["profissional_alternativo"],
                        },
                    )

                    return {
                        "resposta": (
                            f"‚ö†Ô∏è {profissional} est√° {adaptar_genero(profissional, 'ocupad')} √†s {hora}."
                            f"{sugestao_formatada}"
                            f"{alternativa_formatada}"
                            f"\n\nDeseja escolher outro hor√°rio com {profissional} ou prefere agendar com {conflito['profissional_alternativo']}?"
                        ),
                        "acao": None,
                        "dados": {},
                    }

            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao tratar fluxo de agendamento autom√°tico: {e}")
                return {
                    "resposta": "üëã Como posso te ajudar hoje?",
                    "acao": None,
                    "dados": {}
                }

        # üîÑ Caso esteja no meio de um agendamento, ignora o "oi"
        #else:
        #    return {
        #        "resposta": "üîÑ Estamos no meio de um agendamento. Por favor, diga o nome da profissional, a data ou o hor√°rio desejado para continuar.",
        #        "acao": None,
        #        "dados": {}
        #    }

        # üîç Detecta inten√ß√£o de listar todos os profissionais
        intencao_listagem_ampla = any(p in texto_normalizado for p in [
            "todos os profissionais", "quem trabalha", "quantas profissionais",
            "quais s√£o as profissionais", "todas as profissionais", "todo mundo que trabalha"
        ])

        # üîé Detecta servi√ßo mencionado com base nos servi√ßos dispon√≠veis
        servicos_disponiveis = [s.lower() for p in profissionais for s in p.get("servicos", [])]
        servico_mencionado = None
        for s in servicos_disponiveis:
            if re.search(rf"\b{s.lower()}\b", texto_normalizado):
                servico_mencionado = s.lower()
                break

        data_hora_detectada = interpretar_data_e_hora(texto_usuario)

        # ‚úÖ Aqui: Salva contexto atualizado antes de filtrar profissionais
        memoria_nova = {}

        if servico_mencionado:
            memoria_nova["servico"] = servico_mencionado

        if data_hora_detectada:
            data_hora_iso = data_hora_detectada.replace(second=0, microsecond=0).isoformat()
            if data_hora_iso != contexto_salvo.get("data_hora"):
                memoria_nova["data_hora"] = data_hora_iso

        
        if memoria_nova:
            # üßº Remove data_hora antiga se n√£o vier nova
            if "data_hora" in memoria_nova:
                contexto_salvo["data_hora"] = memoria_nova["data_hora"]
            elif "data_hora" in contexto_salvo:
                print("üßπ Removendo data_hora antiga do contexto")
                del contexto_salvo["data_hora"]

            contexto_salvo.update(memoria_nova)
            await salvar_contexto_temporario(user_id, contexto_salvo)
            contexto_salvo = await carregar_contexto_temporario(user_id) or {}
            if contexto_salvo.get("profissional_escolhido"):
                contexto_salvo.pop("ultima_opcao_profissionais", None)

            data_inteligente = interpretar_data_e_hora(texto_usuario)
            if data_inteligente:
                nova_data_iso = data_inteligente.replace(second=0, microsecond=0).isoformat()
                if nova_data_iso != contexto_salvo.get("data_hora"):
                    contexto_salvo["data_hora"] = nova_data_iso
                    print(f"üß† Data/hora atualizada para: {nova_data_iso}")
                    await salvar_contexto_temporario(user_id, contexto_salvo)

        if contexto_salvo is None:
            contexto_salvo = {}  # üîß Garante que temos ao menos um dicion√°rio vazio

        # ‚úÖ Garante que o contexto existe como dicion√°rio
        contexto = contexto or {}

        # üß† Decide se filtra ou mant√©m todos
        if servico_mencionado and not intencao_listagem_ampla:
            profissionais_filtrados = [
                p for p in profissionais
                if servico_mencionado in [s.lower() for s in p.get("servicos", [])]
            ]
        else:
            profissionais_filtrados = profissionais  # Usa todos

        # Se houver um hor√°rio detectado, filtre apenas os dispon√≠veis nesse hor√°rio
        if contexto_salvo.get("data_hora"):
            from services.event_service_async import verificar_conflito_e_sugestoes_profissional
            data = datetime.fromisoformat(contexto_salvo["data_hora"])
            data_str = data.strftime("%Y-%m-%d")
            hora_str = data.strftime("%H:%M")
            duracao = estimar_duracao(servico_mencionado) if servico_mencionado else 60

            profissionais_disponiveis = []
            for prof in profissionais_filtrados:

                conflito = await verificar_conflito_e_sugestoes_profissional(
                    user_id=user_id,
                    data=data_str,
                    hora_inicio=hora_str,
                    duracao_min=duracao,
                    profissional=prof["nome"],
                    servico=servico_mencionado or ""
                )
                if not conflito["conflito"]:
                    profissionais_disponiveis.append(prof)

            contexto["profissionais"] = profissionais_disponiveis
        else:
            profissionais_disponiveis = profissionais_filtrados
            contexto["profissionais"] = profissionais_disponiveis

        # ‚úÖ Listagem direta de profissionais
        if intencao_listagem_ampla and profissionais_disponiveis:
            profissionais_formatados = [
                f"- {p['nome']}: {', '.join(p['servicos'])}" for p in profissionais_disponiveis
            ]
            await atualizar_contexto(user_id, {
                "usuario": texto_usuario,
                "bot": "Aqui est√£o as profissionais cadastradas:\n" + "\n".join(profissionais_formatados)
            })
            return {
                "resposta": "Aqui est√£o as profissionais cadastradas:\n" + "\n".join(profissionais_formatados),
                "acao": None,
                "dados": {}
            }

        # ‚úÖ Novo: se temos profissionais dispon√≠veis, mas ainda n√£o h√° um escolhido, sugerimos nomes
        if profissionais_disponiveis and not contexto_salvo.get("profissional_escolhido"):
            servico_para_frase = servico_mencionado or contexto_salvo.get("servico")
    
            if not servico_para_frase:
                return {
                    "resposta": "Para te mostrar os profissionais corretos, qual servi√ßo voc√™ deseja?",
                    "acao": "aguardar_servico",
                    "dados": {}
                }

            # üß† Atualiza nome do servi√ßo se novo
            if servico_mencionado and contexto_salvo.get("servico") != servico_mencionado:
                contexto_salvo["servico"] = servico_mencionado

            nomes = [p["nome"] for p in profissionais_disponiveis]
            contexto_salvo["ultima_opcao_profissionais"] = nomes

            servico_para_frase = (
                servico_mencionado or contexto_salvo.get("servico")
            ).strip()

            data_hora_str = contexto_salvo.get("data_hora")
            data_formatada = formatar_data(data_hora_str) if data_hora_str else "em breve"

            resposta = f"Temos disponibilidade para {servico_para_frase} {data_formatada}. Deseja ser atendido por {' ou '.join(nomes)}?"

            await atualizar_contexto(user_id, {
                "usuario": texto_usuario,
                "bot": resposta
            })

            await salvar_contexto_temporario(user_id, contexto_salvo)

            return {
                "resposta": resposta,
                "acao": None,
                "dados": {}
            }

        # üß† Salva tamb√©m o servi√ßo mencionado (se houver) para uso posterior
        if servico_mencionado:
            contexto_salvo = await carregar_contexto_temporario(user_id) or {}
            if contexto_salvo.get("profissional_escolhido"):
                contexto_salvo.pop("ultima_opcao_profissionais", None)

            data_inteligente = interpretar_data_e_hora(texto_usuario)
            if data_inteligente:
                nova_data_iso = data_inteligente.replace(second=0, microsecond=0).isoformat()
                if nova_data_iso != contexto_salvo.get("data_hora"):
                    contexto_salvo["data_hora"] = nova_data_iso
                    print(f"üß† Data/hora atualizada para: {nova_data_iso}")
                    await salvar_contexto_temporario(user_id, contexto_salvo)

        nomes_profissionais = [p["nome"].lower() for p in contexto["profissionais"]]
        resposta_direta = texto_usuario.strip().lower()

        contexto_salvo = await carregar_contexto_temporario(user_id)
        print("üì• Contexto salvo atual:", contexto_salvo)  # üëà Coloque aqui

        # ‚úÖ Novo: o usu√°rio respondeu diretamente com um nome da √∫ltima sugest√£o?
        resposta_direta = texto_usuario.strip().title()
        opcoes_anteriores = contexto_salvo.get("ultima_opcao_profissionais", [])

        if any(resposta_direta.lower() in nome.lower() for nome in opcoes_anteriores):
            profissional = next((n for n in opcoes_anteriores if resposta_direta.lower() in n.lower()), resposta_direta)
            servico = contexto_salvo.get("servico")
            data_hora = contexto_salvo.get("data_hora")
  
            if servico and data_hora:
                duracao = estimar_duracao(servico)
                data_obj = datetime.fromisoformat(data_hora)
                data_str = data_obj.strftime("%Y-%m-%d")
                hora_str = data_obj.strftime("%H:%M")

                from services.event_service_async import verificar_conflito_e_sugestoes_profissional
                conflito = await verificar_conflito_e_sugestoes_profissional(
                    user_id=user_id,
                    data=data_str,
                    hora_inicio=hora_str,
                    duracao_min=duracao,
                    profissional=profissional,
                    servico=servico
                )

                if conflito["conflito"]:
                    sugestoes = conflito.get("sugestoes", [])
                    alternativa = conflito.get("profissional_alternativo")
                    sugestoes_txt = (
                        "\n".join(f"üîÑ {h}" for h in sugestoes)
                        if sugestoes else ""
                    )
                    sugestao_formatada = (
                        f"\n\nüìå *Hor√°rios dispon√≠veis com {profissional}:*\n{sugestoes_txt}"
                        if sugestoes_txt else ""
                    )
                    alternativa_formatada = (
                         f"\n\nüí° {alternativa} est√° dispon√≠vel √†s {hora_str}."
                        if alternativa else ""
                    )

                    await salvar_contexto_temporario(user_id, {
                        "profissional_escolhido": profissional,
                        "servico": servico,
                        "data_hora": data_hora,
                        "sugestoes": sugestoes,
                        "alternativa_profissional": alternativa
                    })

                    return {
                        "resposta": (
                            f"‚ö†Ô∏è {profissional} est√° {adaptar_genero(profissional, 'ocupad')} √†s {hora_str}."
                            f"{sugestao_formatada}"
                            f"{alternativa_formatada}"
                            f"\n\nDeseja escolher outro hor√°rio com {profissional} ou prefere agendar com {alternativa}?"
                        ),
                        "acao": None,
                        "dados": {}
                    }

                # ‚úÖ Se n√£o houver conflito
                await salvar_contexto_temporario(user_id, {
                    "profissional_escolhido": profissional,
                    "servico": servico,
                    "data_hora": data_hora,
                    "evento_criado": True,
                    "ultima_acao": "criar_evento",
                    "ultima_intencao": "criar_evento",
                    "dados_anteriores": {
                        "profissional": profissional,
                        "servico": servico,
                        "data_hora": data_hora,
                        "duracao": duracao
                    }
                })

                await limpar_contexto_agendamento(user_id)

                return {
                    "resposta": f"{servico.capitalize()} agendado com {profissional} para {formatar_data(data_hora)}. ‚úÇÔ∏è",
                    "acao": "criar_evento",
                    "dados": {
                        "data_hora": data_hora,
                        "descricao": formatar_descricao_evento(servico, profissional),
                        "duracao": duracao,
                        "profissional": profissional
                    }
                }

            else:
                await salvar_contexto_temporario(user_id, {
                    "profissional_escolhido": profissional
                })
                await limpar_contexto_agendamento(user_id)
                return {
                    "resposta": f"Perfeito! {profissional} foi selecionada. Agora diga a data e o hor√°rio que voc√™ prefere.",
                    "acao": None,
                    "dados": {}
                }

        # ‚è∞ Novo trecho: captura hor√°rio direto se j√° tem profissional e servi√ßo
        hora_encontrada = re.search(r'\b(\d{1,2})(?:[:h](\d{2}))?\b', resposta_direta)
        if hora_encontrada:
            hora = int(hora_encontrada.group(1))
            minuto = int(hora_encontrada.group(2) or 0)

            profissional = contexto_salvo.get("profissional_escolhido")
            servico = contexto_salvo.get("servico")
            data_hora_antiga = contexto_salvo.get("data_hora")

            if profissional and servico:
                if data_hora_antiga:
                    data_original = datetime.fromisoformat(data_hora_antiga)
                else:
                    data_original = datetime.now()

                nova_data_hora = data_original.replace(hour=hora, minute=minuto, second=0, microsecond=0).isoformat()
                duracao = estimar_duracao(servico)

                await salvar_contexto_temporario(user_id, {
                    "profissional_escolhido": profissional,
                    "servico": servico,
                    "data_hora": nova_data_hora,
                    "evento_criado": True
                })

                await limpar_contexto_agendamento(user_id)

                return {
                    "resposta": f"{servico.capitalize()} agendado com {profissional} para {formatar_data(nova_data_hora)}. ‚úÇÔ∏è",
                    "acao": "criar_evento",
                    "dados": {
                        "data_hora": nova_data_hora,
                        "descricao": formatar_descricao_evento(servico, profissional),
                        "duracao": duracao,
                        "profissional": profissional
                    }
                }

        # üéØ Verifica se a resposta menciona diretamente um profissional
        texto_normalizado = unidecode.unidecode(resposta_direta.lower())

        for prof in nomes_profissionais:
            prof_normalizado = unidecode.unidecode(prof.lower())

            # Permite detectar frases como "pela Carla", "com a Carla", "Carla"
            if re.search(rf"\b(pela|com|com a|a|para|por)?\s*{prof_normalizado}\b", texto_normalizado):
                contexto_salvo["profissional_escolhido"] = prof.capitalize()
                opcoes_disponiveis = contexto_salvo.get("ultima_opcao_profissionais") or []

                # üîÅ Fallback inteligente: se n√£o houver lista, usa alternativa_profissional
                if not opcoes_disponiveis and contexto_salvo.get("alternativa_profissional"):
                    opcoes_disponiveis = [contexto_salvo["alternativa_profissional"]]

                servico = contexto_salvo.get("servico")
                data_hora = contexto_salvo.get("data_hora")

                print(f"üîç Verifica√ß√£o de dados: profissional={prof.capitalize()}, servico={servico}, data_hora={data_hora},    op√ß√µes={opcoes_disponiveis}")

                if prof.capitalize() in opcoes_disponiveis and servico and data_hora:
                    duracao = estimar_duracao(servico)
                    await salvar_contexto_temporario(user_id, {
                        "profissional_escolhido": prof.capitalize(),
                        "servico": servico,
                        "data_hora": data_hora,
                        "evento_criado": True
                    })
                    await limpar_contexto_agendamento(user_id)
                    return {
                        "resposta": f"{servico.capitalize()} agendado com {prof.capitalize()} para {formatar_data(data_hora)}. ‚úÇÔ∏è",
                        "acao": "criar_evento",
                        "dados": {
                            "data_hora": data_hora,
                            "descricao": f"{servico} com {prof.capitalize()}",
                            "duracao": duracao
                        }
                    }
                else:
                    # üß† Salva o profissional escolhido e tenta completar depois
                    await salvar_contexto_temporario(user_id, {"profissional_escolhido": prof.capitalize()})
                    contexto_salvo = await carregar_contexto_temporario(user_id)

                    if contexto_salvo.get("evento_criado") and not contexto_salvo.get("ultima_acao"):
                        await limpar_contexto_agendamento(user_id)
                        return {
                            "resposta": "‚úÖ O agendamento anterior foi registrado com sucesso. Podemos seguir com outro pedido?",
                            "acao": None,
                            "dados": {}
                        }

                    profissional = contexto_salvo.get("profissional_escolhido")
                    servico = contexto_salvo.get("servico")
                    data_hora = contexto_salvo.get("data_hora")

                    if profissional and servico and data_hora:
                        duracao = estimar_duracao(servico)
                        await salvar_contexto_temporario(user_id, {"evento_criado": True})
                        await limpar_contexto_agendamento(user_id)
                        return {
                            "resposta": f"{servico.capitalize()} agendado com {profissional} para {formatar_data(data_hora)}. ‚úÇÔ∏è",
                            "acao": "criar_evento",
                            "dados": {
                                "data_hora": data_hora,
                                "descricao": formatar_descricao_evento(servico, profissional),
                                "duracao": duracao
                            }
                        }

        # üîç Garante que os dados do cliente estejam no contexto
        cliente = await buscar_cliente(user_id)
        if cliente:
            contexto["usuario"] = cliente
            contexto["pagamentoAtivo"] = cliente.get("pagamentoAtivo", False)
            contexto["planosAtivos"] = cliente.get("planosAtivos", [])

            messages = montar_prompt_com_contexto(INSTRUCAO_SECRETARIA, contexto, contexto_salvo, texto_usuario)

            resposta = await client.chat.completions.create(
                model="gpt-4o",
                temperature=0.4,
                messages=messages
            )
            firestore_client = firestore.client()
            await registrar_custo_gpt(resposta, "gpt-4o", user_id, firestore_client)
 
            try:
                conteudo = resposta.choices[0].message.content
                if conteudo:
                    conteudo = conteudo.strip()
                else:
                    raise ValueError("Conte√∫do da resposta do GPT veio vazio.")

                print("üì® Conte√∫do bruto do GPT:\n", conteudo)

                if "{" in conteudo and "}" in conteudo:
                    inicio = conteudo.index("{")
                    fim = conteudo.rindex("}")
                    json_puro = conteudo[inicio:fim + 1]
                else:
                    raise ValueError("JSON mal formado: delimitadores '{' ou '}' ausentes.")

                resultado = json.loads(json_puro)

            except Exception as e:
                print("üõë Erro ao interpretar resposta do GPT:")
                print(f"‚ùó Tipo de erro: {type(e).__name__}")
                print(f"‚ùó Erro: {e}")
                print("üì¶ Objeto de resposta bruto:")
                print(resposta.model_dump_json(indent=2, ensure_ascii=False))

                return {
                    "resposta": "‚ùå A IA respondeu fora do formato esperado. Pode reformular a pergunta?",
                    "acao": None,
                    "dados": {}
                }

            # üü° Salve tamb√©m o servi√ßo e a data_hora se existirem, mesmo que estejam fora de 'dados'
            if "descricao" in resultado.get("dados", {}):
                descricao = resultado["dados"]["descricao"].lower()
                if "com" in descricao:
                    servico_detectado = descricao.split("com")[0].strip()
                    memoria_nova["servico"] = servico_detectado
                else:
                    memoria_nova["servico"] = descricao

            if "data_hora" in resultado.get("dados", {}):
                memoria_nova["data_hora"] = resultado["dados"]["data_hora"]

            # ‚úÖ Verifica se j√° temos os 3 elementos e agenda diretamente
            profissional = memoria_nova.get("profissional_escolhido") or contexto_salvo.get("profissional_escolhido")
            servico = memoria_nova.get("servico") or contexto_salvo.get("servico")
            data_hora = memoria_nova.get("data_hora") or contexto_salvo.get("data_hora")

            if (
                profissional
                and servico
                and data_hora
                and not contexto_salvo.get("sugestoes")
                and not contexto_salvo.get("alternativa_profissional")
            ):
                duracao = estimar_duracao(servico)

                await salvar_contexto_temporario(user_id, {
                    "evento_criado": True,
                    "ultima_acao": "criar_evento",
                    "ultima_intencao": "criar_evento",
                    "dados_anteriores": {
                        "data_hora": data_hora,
                        "descricao": formatar_descricao_evento(servico, profissional),
                        "duracao": duracao,
                        "profissional": profissional
                    }
                })

                return {
                    "resposta": f"{servico.capitalize()} agendado com {profissional} para {formatar_data(data_hora)}. ‚úÇÔ∏è",
                    "acao": "criar_evento",
                    "dados": {
                        "data_hora": data_hora,
                        "descricao": formatar_descricao_evento(servico, profissional),
                        "duracao": duracao,
                        "profissional": profissional
                    }
                }

            # üõ°Ô∏è Protege contra acionamento incorreto de "consultar_preco_servico"
            texto_normalizado = unidecode.unidecode(texto_usuario.lower())
            menciona_preco = any(p in texto_normalizado for p in ["preco", "pre√ßo", "valor", "quanto", "custa"])

            # ‚ö†Ô∏è Corrige interpreta√ß√£o autom√°tica mal feita
            if resultado.get("acao") == "consultar_preco_servico" and not menciona_preco:
                resultado["acao"] = None
                resultado["dados"] = {}

            # ‚úÖ Se n√£o veio a√ß√£o mas mencionou um servi√ßo e a inten√ß√£o foi clara de pre√ßo, for√ßa como consulta
            elif resultado.get("acao") is None and servico_mencionado and menciona_preco:
                resultado["acao"] = "consultar_preco_servico"
                resultado["dados"] = {"servico": servico_mencionado}

            memoria_nova = {}

            # üß© Corre√ß√£o autom√°tica se o GPT ignorar profissionais do contexto
            intencao_listagem_ampla = any(p in texto_usuario.lower() for p in [
                "todos os profissionais", "quem trabalha", "quantas profissionais",
                "quais s√£o as profissionais", "todas as profissionais", "todo mundo que trabalha"
            ])

            if (
                intencao_listagem_ampla
                and contexto.get("profissionais")
                and not resultado.get("acao")
                and not resultado.get("resposta")
            ):

                profissionais_formatados = [
                    f"- {p['nome']}: {', '.join(p['servicos'])}" for p in contexto["profissionais"]
                ]
                resultado["resposta"] = "Aqui est√£o as profissionais cadastradas:\n" + "\n".join(profissionais_formatados)
                resultado["acao"] = None
                resultado["dados"] = {}

            if "profissional" in resultado.get("dados", {}):
                memoria_nova["profissional_escolhido"] = resultado["dados"]["profissional"]

            if "data_hora" in resultado.get("dados", {}):
                memoria_nova["data_hora"] = resultado["dados"]["data_hora"]

            # Verificar se a resposta cont√©m algum nome de profissional
            nomes_validos = [p["nome"] for p in contexto.get("profissionais", [])]
            nomes_mencionados = []
            if "resposta" in resultado:
                nomes_mencionados = [nome for nome in nomes_validos if nome.lower() in resultado["resposta"].lower()]

            # Detectar inten√ß√£o de listagem ampla (n√£o salvar profissional nesse caso)
            intencao_listagem_ampla = any(p in texto_usuario.lower() for p in [
                "todos os profissionais", "quem trabalha", "quantas profissionais",
                "quais s√£o as profissionais", "todas as profissionais", "todo mundo que trabalha"
            ])

            # Salvar profissional escolhido se:
            # 1. S√≥ um nome foi mencionado E
            # 2. N√£o √© uma listagem ampla
            # OU
            # 3. O nome mencionado estava na √∫ltima listagem (continuidade de atendimento)
            if (
                len(nomes_mencionados) == 1 and not intencao_listagem_ampla
            ) or (
                len(nomes_mencionados) == 1
                and "ultima_opcao_profissionais" in contexto
                and nomes_mencionados[0] in contexto["ultima_opcao_profissionais"]
            ):
                memoria_nova["ultima_opcao_profissionais"] = [nomes_mencionados[0]]
                memoria_nova["profissional_escolhido"] = nomes_mencionados[0]

            # üü° Salve tamb√©m o servi√ßo e a data_hora se existirem, mesmo que estejam fora de 'dados'
            if "descricao" in resultado.get("dados", {}):
                descricao = resultado["dados"]["descricao"]
                memoria_nova["servico"] = descricao.split(" com ")[0].strip().lower()

            if "data_hora" in resultado.get("dados", {}):
                memoria_nova["data_hora"] = resultado["dados"]["data_hora"]


            # ‚úÖ Antes de salvar, verifique se j√° d√° para agendar
            profissional = memoria_nova.get("profissional_escolhido") or contexto_salvo.get("profissional_escolhido")
            servico = memoria_nova.get("servico") or contexto_salvo.get("servico")
            data_hora = memoria_nova.get("data_hora") or contexto_salvo.get("data_hora")

            if profissional and servico and data_hora:
                duracao = estimar_duracao(servico)
                start_dt = datetime.fromisoformat(data_hora)
                data = start_dt.strftime("%Y-%m-%d")
                hora = start_dt.strftime("%H:%M")

                from services.event_service_async import verificar_conflito_e_sugestoes_profissional
                conflito_info = await verificar_conflito_e_sugestoes_profissional(
                    user_id=user_id,
                    data=data,
                    hora_inicio=hora,
                    duracao_min=duracao,
                    profissional=profissional,
                    servico=servico
                )

                if conflito_info["conflito"]:
                    sugestoes = conflito_info.get("sugestoes", [])
                    alternativa = conflito_info.get("profissional_alternativo")
                    sugestoes_txt = (
                        "\n".join(f"üîÑ {h}" for h in sugestoes)
                        if sugestoes else ""
                    )
                    sugestao_formatada = (
                        f"\n\nüìå *Hor√°rios dispon√≠veis com {profissional}:*\n{sugestoes_txt}"
                        if sugestoes_txt else ""
                    )
                    alternativa_formatada = (
                        f"\n\nüí° {alternativa} est√° dispon√≠vel √†s {hora}."
                        if alternativa else ""
                    )

                    await salvar_contexto_temporario(user_id, {
                        "profissional_escolhido": profissional,
                        "servico": servico,
                        "data_hora": data_hora,
                        "sugestoes": sugestoes,
                        "alternativa_profissional": alternativa
                    })

                    resultado = {
                        "resposta": (
                            f"‚ö†Ô∏è {profissional} est√° {adaptar_genero(profissional, 'ocupad')} √†s {hora}."
                            f"{sugestao_formatada}"
                            f"{alternativa_formatada}"
                            f"\n\nDeseja escolher outro hor√°rio com {profissional} ou prefere agendar com {alternativa}?"
                        ),
                        "acao": None,
                        "dados": {}
                    }
                    return resultado

                else:
                    resultado["acao"] = "criar_evento"
                    resultado["dados"] = {
                        "data_hora": data_hora,
                        "descricao": formatar_descricao_evento(servico, profissional),
                        "duracao": duracao
                    }

            # ‚úÖ Salvar tudo junto
            if memoria_nova:
                contexto_salvo = await carregar_contexto_temporario(user_id) or {}
                if contexto_salvo.get("profissional_escolhido"):
                    contexto_salvo.pop("ultima_opcao_profissionais", None)

                data_inteligente = interpretar_data_e_hora(texto_usuario)
                if data_inteligente:
                    nova_data_iso = data_inteligente.replace(second=0, microsecond=0).isoformat()
                    if nova_data_iso != contexto_salvo.get("data_hora"):
                        contexto_salvo["data_hora"] = nova_data_iso
                        print(f"üß† Data/hora atualizada para: {nova_data_iso}")
                        await salvar_contexto_temporario(user_id, contexto_salvo)

                contexto_salvo.update(memoria_nova)
                await salvar_contexto_temporario(user_id, contexto_salvo)

            # üîß Adiciona sugest√£o de profissionais compat√≠veis com o servi√ßo, se for o caso
            if (
                servico_mencionado
                and resultado.get("acao") not in ["criar_evento", "consultar_preco_servico"]
                and resultado.get("resposta")
                and contexto.get("profissionais")
            ):
                profissionais_compativeis = []
                for p in contexto["profissionais"]:
                    servicos = [s.lower() for s in p.get("servicos", []) if isinstance(s, str)]
                    if servico_mencionado in servicos:
                        profissionais_compativeis.append(p["nome"])

                if profissionais_compativeis:
                    profissionais_compativeis = list(set(profissionais_compativeis))  # remove duplicados
                    nomes_formatados = ", ".join(profissionais_compativeis)

                    resposta_atual = resultado["resposta"].strip().lower()

                    # ‚úÖ Evita repetir se nomes j√° estiverem mencionados
                    nomes_ja_mencionados = all(
                        nome.lower() in resposta_atual for nome in profissionais_compativeis
                    )

                    if not nomes_ja_mencionados:
                        resposta_base = resultado["resposta"].strip()

                        # Remove final padr√£o do GPT se existir
                        resposta_base = re.sub(
                            r"deseja ser atendido por.*?$", "", resposta_base, flags=re.IGNORECASE
                        ).strip()

                        nova_resposta = f"{resposta_base} Deseja ser atendido por {nomes_formatados}?"
                        resultado["resposta"] = nova_resposta

                    if (
                        servico_mencionado
                        and data_hora_detectada
                        and contexto["profissionais"]  # se houver sugest√µes reais
                    ):
                        await salvar_contexto_temporario(user_id, {
                            "servico": servico_mencionado,
                            "data_hora": data_hora_detectada.isoformat(),
                            "ultima_acao": "criar_evento",
                            "ultima_intencao": "criar_evento",
                            "dados_anteriores": {
                                "data_hora": data_hora_detectada.isoformat(),
                                "duracao": estimar_duracao(servico_mencionado),
                                "descricao": f"{servico_mencionado.capitalize()} com ...",  # incompleto
                                "profissional": None  # aguarda o usu√°rio escolher
                            },
                            "ultima_opcao_profissionais": [p["nome"] for p in contexto["profissionais"]]
                        })


            if resultado.get("acao") and resultado.get("dados"):
                await salvar_contexto_temporario(user_id, {
                    "ultima_acao": resultado["acao"],
                    "dados_anteriores": resultado["dados"],
                    "ultima_intencao": resultado.get("acao")  # üëà mesma a√ß√£o por padr√£o
                })
                if resultado["acao"] == "criar_evento":
                    await limpar_contexto_agendamento(user_id)  # ‚úÖ ADICIONE AQUI

            # üß† Se houver inten√ß√£o nova e n√£o estiver em meio a execu√ß√£o de a√ß√£o, pode limpar contexto
            if resultado.get("acao") is None and intencao not in ["AGENDAR", "DESCONHECIDO"]:
                if any(contexto_salvo.get(k) for k in ["profissional_escolhido", "servico", "data_hora"]):
                    print("üßπ Mudan√ßa de assunto detectada sem a√ß√£o pendente. Limpando contexto.")
                    await limpar_contexto(user_id)
                    await resetar_sessao(user_id)
                    contexto_salvo = {}

             # ‚úÖ Verifica√ß√µes finais ap√≥s processar toda a l√≥gica principal
            if contexto_salvo.get("evento_criado") and not contexto_salvo.get("ultima_acao"):
                await limpar_contexto_agendamento(user_id)

                return {
                    "resposta": "üëã Ol√°! Em que mais posso te ajudar hoje?",
                    "acao": None,
                    "dados": {}
                }

            elif any(contexto_salvo.get(k) for k in ["servico", "data_hora", "profissional_escolhido"]):
                return {
                    "resposta": "üòä Podemos continuar de onde paramos. Deseja confirmar o profissional ou hor√°rio?",
                    "acao": None,
                    "dados": {}
                }

            return resultado

    except json.JSONDecodeError:
        return {
            "resposta": "‚ùå A IA respondeu fora do formato esperado.",
            "acao": None,
            "dados": {}
        }
    except Exception as e:
        print(f"‚ùå Erro em processar_com_gpt_com_acao: {e}")
        traceback.print_exc()
        return {
            "resposta": "‚ùå Ocorreu um erro ao tentar entender seu pedido.",
            "acao": None,
            "dados": {}
        }

from services.firebase_service_async import buscar_cliente

# ‚úÖ Organiza√ß√£o da semana (com dados de plano no prompt)
async def organizar_semana_com_gpt(tarefas: list, eventos: list, user_id: str, dia_inicio: str = "hoje"):
    try:
        hoje = datetime.now().date()

        dias_formatados = [
            (hoje + timedelta(days=i)).strftime("%A (%d/%m)") for i in range(5)
        ]

        # üîç Busca dados do cliente
        cliente = await buscar_cliente(user_id)
        pagamento_ativo = cliente.get("pagamentoAtivo", False) if cliente else False
        planos_ativos = cliente.get("planosAtivos", []) if cliente else []

        # üß† Prompt completo com contexto
        prompt = f"""
üìå Plano ativo: {pagamento_ativo}
üîê M√≥dulos: {', '.join(planos_ativos) or 'Nenhum'}

Voc√™ √© uma assistente virtual especializada em produtividade e organiza√ß√£o semanal.

Ajude o usu√°rio a planejar os pr√≥ximos 5 dias, a partir de hoje: *{hoje.strftime("%A (%d/%m)")}.*  
Use os dias reais a seguir:

{chr(10).join(f"- {dia}" for dia in dias_formatados)}

Com base nas tarefas e eventos abaixo, distribua as atividades de forma inteligente e priorize o que √© mais importante primeiro.

- Use t√≠tulo com o dia da semana e data. Ex: üìÖ Sexta-feira (11/04)
- Organize os itens como: tarefas primeiro, eventos depois.
- Use emojis para dar destaque.
- Seja objetiva e evite texto explicativo.

Tarefas:
{chr(10).join(f"- {t}" for t in tarefas) or 'Nenhuma'}

Eventos:
{chr(10).join(f"- {e}" for e in eventos) or 'Nenhum'}

Responda apenas com o plano formatado.
"""

        resposta = await client.chat.completions.create(
            model="gpt-4o",
            temperature=0.4,
            messages=[
                {"role": "system", "content": INSTRUCAO_SECRETARIA},
                {"role": "user", "content": prompt}
            ]
        )

        return resposta.choices[0].message.content.strip()

    except Exception as e:
        print(f"[GPT] Erro ao organizar semana: {e}")
        return "‚ùå Houve um erro ao tentar planejar sua semana."