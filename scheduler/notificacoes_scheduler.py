# scheduler/notificacao_scheduler.py

from datetime import datetime
from pytz import timezone
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from services.firebase_service_async import buscar_subcolecao, atualizar_dado_em_path
from telegram import Bot
import os
import logging

logger = logging.getLogger(__name__)

FUSO_BR = timezone("America/Sao_Paulo")

async def processar_notificacoes_agendadas():
    print("‚è∞ Verificando notifica√ß√µes agendadas...")

    try:
        # üîç Itera por todos os usu√°rios
        clientes = await buscar_subcolecao("Clientes")
        agora = datetime.now(FUSO_BR)

        for user_id in clientes.keys():
            path = f"Clientes/{user_id}/NotificacoesAgendadas"
            notificacoes = await buscar_subcolecao(path)

            if not notificacoes:
                continue

            for notif_id, notif in notificacoes.items():
                if notif.get("avisado"):
                    continue

                data_hora_str = notif.get("data_hora")
                canal = notif.get("canal", "telegram")
                mensagem = notif.get("mensagem", "üìå Lembrete")

                try:
                    data_hora = datetime.fromisoformat(data_hora_str).astimezone(FUSO_BR)
                except Exception as e:
                    logger.error(f"Erro ao converter data_hora da notifica√ß√£o: {e}")
                    continue

                if data_hora <= agora:
                    try:
                        if canal == "telegram":
                            bot = Bot(token=os.getenv("TOKEN"))
                            await bot.send_message(chat_id=int(user_id), text=mensagem)

                        elif canal == "whatsapp":
                            from services.whatsapp_service import enviar_mensagem_whatsapp
                            await enviar_mensagem_whatsapp(user_id, mensagem)

                        else:
                            logger.warning(f"üîÅ Canal desconhecido '{canal}' para {user_id}")

                        # üîÅ Marca como avisado
                        await atualizar_dado_em_path(f"{path}/{notif_id}", {"avisado": True})
                        print(f"‚úÖ Notifica√ß√£o enviada para {user_id} via {canal}: {mensagem}")

                    except Exception as e:
                        logger.error(f"Erro ao enviar notifica√ß√£o para {user_id} via {canal}: {e}")

    except Exception as e:
        logger.error(f"‚ùå Erro na rotina de notifica√ß√µes: {e}")

async def enviar_resumo_diario():
    print("üìã Enviando resumo di√°rio completo...")

    try:
        from services.event_service_async import buscar_eventos_por_intervalo
        from services.firebase_service_async import buscar_dado_em_path, buscar_subcolecao
        clientes = await buscar_subcolecao("Clientes")
        hoje = datetime.now(FUSO_BR).date()
        hoje_str = hoje.strftime("%Y-%m-%d")

        for user_id in clientes.keys():
            partes_resumo = []

            # üéØ Eventos do dia
            eventos = await buscar_eventos_por_intervalo(user_id, dia_especifico=hoje)
            if eventos:
                partes_resumo.append("üìÖ *Eventos de hoje:*\n" + "\n".join(f"‚Ä¢ {e}" for e in eventos))
            else:
                partes_resumo.append("üìÖ Nenhum evento agendado.")

            # üìå Tarefas
            tarefas_dict = await buscar_subcolecao(f"Clientes/{user_id}/Tarefas") or {}
            tarefas = [t["descricao"] for t in tarefas_dict.values() if isinstance(t, dict)]
            if tarefas:
                partes_resumo.append("üìù *Tarefas pendentes:*\n" + "\n".join(f"‚Ä¢ {t}" for t in tarefas))
            else:
                partes_resumo.append("üìù Nenhuma tarefa registrada.")

            # üìû Follow-ups
            followups_dict = await buscar_subcolecao(f"Usuarios/{user_id}/FollowUps") or {}
            pendentes = []
            for f in followups_dict.values():
                if f.get("status") == "pendente":
                    nome = f.get("nome_cliente", "Sem nome")
                    data = f.get("data", hoje_str)
                    if data == hoje_str:
                        hora = f.get("hora", "08:00")
                        pendentes.append(f"{nome} √†s {hora}")

            if pendentes:
                partes_resumo.append("üìå *Follow-ups de hoje:*\n" + "\n".join(f"‚Ä¢ {p}" for p in pendentes))
            else:
                partes_resumo.append("üìå Nenhum follow-up para hoje.")

            # üì® Envia tudo junto
            texto = "\n\n".join(partes_resumo)

            try:
                bot = Bot(token=os.getenv("TOKEN"))
                await bot.send_message(chat_id=int(user_id), text=texto, parse_mode="Markdown")
                print(f"‚úÖ Resumo di√°rio enviado para {user_id}")
            except Exception as e:
                logger.error(f"Erro ao enviar resumo di√°rio para {user_id}: {e}")

    except Exception as e:
        logger.error(f"‚ùå Erro ao gerar resumo di√°rio: {e}")

def start_notificacao_scheduler():
    scheduler = AsyncIOScheduler(timezone=FUSO_BR)
    scheduler.add_job(processar_notificacoes_agendadas, "interval", minutes=15)

    # üïó Agenda o envio di√°rio da agenda √†s 08:00
    scheduler.add_job(enviar_resumo_diario, "cron", hour=8, minute=0)

    scheduler.start()
    print("‚úÖ Scheduler de notifica√ß√µes iniciado com envio di√°rio √†s 08:00.")