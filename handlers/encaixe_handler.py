# handlers/encaixe_handler.py
import re
import dateparser
from datetime import timedelta
from pytz import timezone
from telegram import Update
from telegram.ext import ContextTypes

from services.encaixe_service import solicitar_encaixe

FUSO_BR = timezone("America/Sao_Paulo")

# --- util simples para extrair dados do texto ---
def _extrair_profissional(txt: str) -> str | None:
    # exemplos que pega: "com a Carla", "com Carla", "com o Jo√£o", "Carla"
    m = re.search(r"\bcom\s+(a|o)?\s*([A-Za-z√Ä-√ø][\w√Ä-√ø]+)", txt, flags=re.IGNORECASE)
    if m:
        return m.group(2).strip().capitalize()
    # fallback: tenta √∫ltima palavra capitalizada
    m2 = re.search(r"\b([A-Za-z√Ä-√ø][\w√Ä-√ø]+)$", txt.strip())
    return m2.group(1).capitalize() if m2 else None

def _extrair_duracao(txt: str, padrao_min: int = 30) -> int:
    m = re.search(r"(\d{1,3})\s*(min|minuto|minutos)", txt, flags=re.IGNORECASE)
    if m:
        return max(10, min(240, int(m.group(1))))
    return padrao_min

def _extrair_datahora(txt: str):
    # entende ‚Äúhoje √†s 16:00‚Äù, ‚Äúamanh√£ 9h‚Äù, ‚Äú12/10 14:30‚Äù, etc.
    dt = dateparser.parse(
        txt,
        languages=["pt"],
        settings={"PREFER_DATES_FROM": "future", "TIMEZONE": "America/Sao_Paulo", "RETURN_AS_TIMEZONE_AWARE": False},
    )
    return FUSO_BR.localize(dt) if dt else None

# --- handler principal ---
async def handle_pedido_encaixe(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Detecta inten√ß√£o de 'encaixe' e tenta executar.
    Ex.: "tem encaixe hoje √†s 16:00 com a Carla? 30min"
    """
    if not update.message or not update.message.text:
        return

    texto = update.message.text.lower()

    # gatilhos de inten√ß√£o de ENCAIXE
    if not any(k in texto for k in ["encaixe", "encaixa", "en-caixe", "tem agenda hoje", "cabem hoje", "urg√™ncia"]):
        return  # n√£o √© pedido de encaixe; deixe outros handlers seguirem

    user_id = str(update.message.from_user.id)          # quem pede
    dono_id = user_id                                   # no seu fluxo atual, o dono fala do pr√≥prio n√∫mero

    dt_desejado = _extrair_datahora(texto)
    if not dt_desejado:
        await update.message.reply_text("‚ùå N√£o entendi a data/hora do encaixe. Pode dizer, por exemplo: *hoje √†s 16:00*?", parse_mode="Markdown")
        return

    prof = _extrair_profissional(texto)                 # opcional
    dur = _extrair_duracao(texto, padrao_min=30)

    # Ajuste r√°pido: se usu√°rio disse s√≥ ‚Äútem encaixe agora?‚Äù, considere agora+10 min
    agora = FUSO_BR.localize(dateparser.parse("agora"))
    if dt_desejado < agora:
        dt_desejado = agora + timedelta(minutes=10)

    await update.message.reply_text("üîé Vou checar e tentar encaixar‚Ä¶")

    resp = await solicitar_encaixe(
        user_id=dono_id,
        descricao="Encaixe solicitado",
        profissional=prof,
        duracao_min=dur,
        dt_desejado=dt_desejado,
        solicitante_user_id=user_id
    )

    status = resp.get("status")
    msg = resp.get("mensagem", "")

    if status == "encaixe_confirmado":
        ev = resp.get("evento", {})
        quando = f"{ev.get('data')} √†s {ev.get('hora_inicio')}"
        prof_txt = f" com {ev.get('profissional')}" if ev.get("profissional") else ""
        await update.message.reply_text(f"‚úÖ Encaixe confirmado{prof_txt}: *{quando}*.", parse_mode="Markdown")
    elif status == "aguardando_respostas":
        await update.message.reply_text("üì® Enviei pedido(s) de reagendamento para clientes com perfil flex√≠vel. Te aviso ao receber resposta.")
    else:
        await update.message.reply_text(f"‚ùå N√£o consegui encaixar agora. {msg}")
